$date
	Fri Oct 10 11:57:07 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module tb_fp_adder $end
$var wire 32 ! result [31:0] $end
$var reg 32 " a [31:0] $end
$var reg 32 # b [31:0] $end
$scope module uut $end
$var wire 32 $ a [31:0] $end
$var wire 32 % b [31:0] $end
$var wire 32 & result [31:0] $end
$var wire 1 ' sign_res $end
$var wire 1 ( sign_b $end
$var wire 1 ) sign_a $end
$var wire 25 * mant_sum [24:0] $end
$var wire 24 + mant_norm [23:0] $end
$var wire 24 , mant_b_shifted [23:0] $end
$var wire 24 - mant_b [23:0] $end
$var wire 24 . mant_a_shifted [23:0] $end
$var wire 24 / mant_a [23:0] $end
$var wire 32 0 fp_result [31:0] $end
$var wire 8 1 exp_norm [7:0] $end
$var wire 8 2 exp_large [7:0] $end
$var wire 8 3 exp_b [7:0] $end
$var wire 8 4 exp_a [7:0] $end
$scope module addsub_stage $end
$var wire 1 ( sign_b $end
$var wire 1 ) sign_a $end
$var wire 24 5 mant_b_shift [23:0] $end
$var wire 24 6 mant_a_shift [23:0] $end
$var reg 25 7 mant_sum [24:0] $end
$var reg 1 ' sign_res $end
$upscope $end
$scope module align_stage $end
$var wire 24 8 mant_b_shift [23:0] $end
$var wire 24 9 mant_b [23:0] $end
$var wire 24 : mant_a_shift [23:0] $end
$var wire 24 ; mant_a [23:0] $end
$var wire 8 < exp_large [7:0] $end
$var wire 8 = exp_diff [7:0] $end
$var wire 8 > exp_b [7:0] $end
$var wire 8 ? exp_a [7:0] $end
$upscope $end
$scope module normalize_stage $end
$var wire 8 @ exp_in [7:0] $end
$var wire 25 A mant_sum [24:0] $end
$var reg 8 B exp_out [7:0] $end
$var reg 1 C found_one $end
$var reg 5 D lz_count [4:0] $end
$var reg 24 E mant_norm [23:0] $end
$var integer 32 F i [31:0] $end
$upscope $end
$scope module pack_stage $end
$var wire 8 G exp_norm [7:0] $end
$var wire 24 H mant_norm [23:0] $end
$var wire 1 ' sign_res $end
$var wire 32 I result [31:0] $end
$var reg 32 J temp_result [31:0] $end
$upscope $end
$scope module unpack_a $end
$var wire 32 K in [31:0] $end
$var wire 1 ) sign $end
$var wire 24 L mant [23:0] $end
$var wire 8 M exp [7:0] $end
$upscope $end
$scope module unpack_b $end
$var wire 32 N in [31:0] $end
$var wire 1 ( sign $end
$var wire 24 O mant [23:0] $end
$var wire 8 P exp [7:0] $end
$upscope $end
$upscope $end
$scope task show $end
$var reg 32 Q a_in [31:0] $end
$var reg 32 R b_in [31:0] $end
$var reg 32 S res_in [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx S
bx R
bx Q
b10000011 P
b101101000000000000000000 O
b1000001101101000000000000000000 N
b10001000 M
b100000000000000000000000 L
b1000100000000000000000000000000 K
b1000100000001011010000000000000 J
b1000100000001011010000000000000 I
b100001011010000000000000 H
b10001000 G
b11111111111111111111111111111111 F
b100001011010000000000000 E
b0 D
1C
b10001000 B
b100001011010000000000000 A
b10001000 @
b10001000 ?
b10000011 >
b101 =
b10001000 <
b100000000000000000000000 ;
b100000000000000000000000 :
b101101000000000000000000 9
b1011010000000000000 8
b100001011010000000000000 7
b100000000000000000000000 6
b1011010000000000000 5
b10001000 4
b10000011 3
b10001000 2
b10001000 1
b1000100000001011010000000000000 0
b100000000000000000000000 /
b100000000000000000000000 .
b101101000000000000000000 -
b1011010000000000000 ,
b100001011010000000000000 +
b100001011010000000000000 *
0)
0(
0'
b1000100000001011010000000000000 &
b1000001101101000000000000000000 %
b1000100000000000000000000000000 $
b1000001101101000000000000000000 #
b1000100000000000000000000000000 "
b1000100000001011010000000000000 !
$end
#10
b11111111111111111111111111111111 F
b0 !
b0 &
b0 0
b0 I
b0 J
b0 .
b0 6
b0 :
0C
b0 +
b0 E
b0 H
b0 1
b0 B
b0 G
b0 *
b0 7
b0 A
b0 -
b0 9
b0 O
b0 /
b0 ;
b0 L
b0 2
b0 <
b0 @
b0 ,
b0 5
b0 8
b0 =
b0 3
b0 >
b0 P
b0 4
b0 ?
b0 M
b0 #
b0 %
b0 N
b0 "
b0 $
b0 K
b1000100000001011010000000000000 S
b1000001101101000000000000000000 R
b1000100000000000000000000000000 Q
#20
b110111101100101000000101 +
b110111101100101000000101 E
b110111101100101000000101 H
b1000011110111101100101000000101 !
b1000011110111101100101000000101 &
b1000011110111101100101000000101 0
b1000011110111101100101000000101 I
b1000011110111101100101000000101 J
b1101111011001010000001011 *
b1101111011001010000001011 7
b1101111011001010000001011 A
b110101000011111010111000 ,
b110101000011111010111000 5
b110101000011111010111000 8
b11111111111111111111111111111111 F
b10000111 1
b10000111 B
b10000111 G
b111010010101010101010011 .
b111010010101010101010011 6
b111010010101010101010011 :
b110101000011111010111000 -
b110101000011111010111000 9
b110101000011111010111000 O
b10000110 2
b10000110 <
b10000110 @
b111010010101010101010011 /
b111010010101010101010011 ;
b111010010101010101010011 L
b10000110 3
b10000110 >
b10000110 P
b10000110 4
b10000110 ?
b10000110 M
b1000011010101000011111010111000 #
b1000011010101000011111010111000 %
b1000011010101000011111010111000 N
b1000011011010010101010101010011 "
b1000011011010010101010101010011 $
b1000011011010010101010101010011 K
b0 S
b0 R
b0 Q
#30
b11000011101100100000001010010000 !
b11000011101100100000001010010000 &
b11000011101100100000001010010000 0
b11000011101100100000001010010000 I
b11000011101100100000001010010000 J
1C
b1 D
b11111111111111111111111111111111 F
b101100100000001010010000 +
b101100100000001010010000 E
b101100100000001010010000 H
b10000111 1
b10000111 B
b10000111 G
1'
b10110010000000101001000 *
b10110010000000101001000 7
b10110010000000101001000 A
b110010110001110011001101 ,
b110010110001110011001101 5
b110010110001110011001101 8
b11100100001101110000101 .
b11100100001101110000101 6
b11100100001101110000101 :
b110010110001110011001101 -
b110010110001110011001101 9
b110010110001110011001101 O
b10001000 2
b10001000 <
b10001000 @
b1 =
b111001000011011100001010 /
b111001000011011100001010 ;
b111001000011011100001010 L
1(
b10001000 3
b10001000 >
b10001000 P
b10000111 4
b10000111 ?
b10000111 M
b11000100010010110001110011001101 #
b11000100010010110001110011001101 %
b11000100010010110001110011001101 N
b1000011111001000011011100001010 "
b1000011111001000011011100001010 $
b1000011111001000011011100001010 K
b1000011110111101100101000000101 S
b1000011010101000011111010111000 R
b1000011011010010101010101010011 Q
#40
b1000010000010000111101011100000 !
b1000010000010000111101011100000 &
b1000010000010000111101011100000 0
b1000010000010000111101011100000 I
b1000010000010000111101011100000 J
b111110100000000000000000 ,
b111110100000000000000000 5
b111110100000000000000000 8
b11111111111111111111111111111111 F
b101 D
1C
b100010000111101011100000 +
b100010000111101011100000 E
b100010000111101011100000 H
b10000100 1
b10000100 B
b10000100 G
0'
b1000100001111010111 *
b1000100001111010111 7
b1000100001111010111 A
b111110100000000000000000 -
b111110100000000000000000 9
b111110100000000000000000 O
b10001001 2
b10001001 <
b10001001 @
b111111100100001111010111 .
b111111100100001111010111 6
b111111100100001111010111 :
b0 =
b111111100100001111010111 /
b111111100100001111010111 ;
b111111100100001111010111 L
b10001001 3
b10001001 >
b10001001 P
b10001001 4
b10001001 ?
b10001001 M
b11000100111110100000000000000000 #
b11000100111110100000000000000000 %
b11000100111110100000000000000000 N
b1000100111111100100001111010111 "
b1000100111111100100001111010111 $
b1000100111111100100001111010111 K
b11000011101100100000001010010000 S
b11000100010010110001110011001101 R
b1000011111001000011011100001010 Q
#50
b1000010000010000111101011100000 S
b11000100111110100000000000000000 R
b1000100111111100100001111010111 Q
#55
